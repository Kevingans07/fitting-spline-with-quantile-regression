pen <- as.numeric(t(beta) %*% S %*% beta) #produces a 1x1 matrix
#loss <- sum((y - mu)^2) + lambda * pen # this is for least square
#smoothed pinball loss For Quantile Regression
pinball_loss <- - sum((tau -plogis(res/psi))* res)
penalty <- lambda * pen
return(pinball_loss+penalty)
}
n <- 1e3
x <- seq(0, 2*pi, length.out =n)
y <- cos(x) +rnorm(n,0,0.5)
data <- data.frame (x=x, y=y)
plot(x,y)
library(mgcv)
#1. Build spline model with smoothCon
spline_model <- smoothCon(s(x,k=10,bs="cr"), data=data, knots=NULL)[[1]]
X <- spline_model$X
S <- spline_model$S[[1]] # penalty matrix S
#2. Define loss function with psi, lambda, sigma
pen_ssqr <- function(beta, X, y, S,
lambda,tau, psi =0.1, sigma =1){
mu <- X %*% beta
res <- (y-mu)
pen <- as.numeric(t(beta) %*% S %*% beta) #produces a 1x1 matrix
#loss <- sum((y - mu)^2) + lambda * pen # this is for least square
#smoothed pinball loss For Quantile Regression
pinball_loss <- - sum((tau -plogis(res/psi))* res)
penalty <- lambda * pen
return(pinball_loss+penalty)
}
fit <- lm(y ~ X-1, data = data)
matplot(X, x=x, type ='l', ylab = "Spline Basis Function")
coef(fit)
plot (x,y, col="grey")
lines(x, X %*% coef(fit), type = 'l', col = "red", lwd = 2)
#3. Optimise
#assume sigma =1
#       psi is small number
#develop code to estimate beta
#FIXED PARAMETERS
tau <- 0.5 #quantile level
lambda <- 100
psi <- 0.1
sigma <- 1 #fixed
fit_pen <- optim(par = fit$coef,
fn = pen_ssqr,
y = y, X = X,
tau = tau, S = S,
lambda = lambda, method = "BFGS",
)
#visualisation
plot(x, y, col = "grey")
lines(x,X %*% coef(fit), type = 'l', col = "blue", lwd = 2)
lines(x, X %*% fit_pen$par, type = 'l', col = "red", lwd = 2)
#3. Optimise
#assume sigma =1
#       psi is small number
#develop code to estimate beta
#FIXED PARAMETERS
tau <- 0.5 #quantile level -> so this is median
lambda <- 100
psi <- 0.1
sigma <- 1 #fixed
fit_pen <- optim(par = fit$coef,
fn = pen_ssqr,
y = y, X = X,
tau = tau, S = S,
lambda = lambda, method = "BFGS",
)
#visualisation
plot(x, y, col = "grey")
lines(x,X %*% coef(fit), type = 'l', col = "blue", lwd = 2)
lines(x, X %*% fit_pen$par, type = 'l', col = "red", lwd = 2)
#3. Optimise
#assume sigma =1
#       psi is small number
#develop code to estimate beta
#FIXED PARAMETERS
tau <- 0.9 #quantile level -> so this is median
lambda <- 100
psi <- 0.1
sigma <- 1 #fixed
fit_pen <- optim(par = fit$coef,
fn = pen_ssqr,
y = y, X = X,
tau = tau, S = S,
lambda = lambda, method = "BFGS",
)
#visualisation
plot(x, y, col = "grey")
lines(x,X %*% coef(fit), type = 'l', col = "blue", lwd = 2)
lines(x, X %*% fit_pen$par, type = 'l', col = "red", lwd = 2)
library(mgcv)
#1. Build spline model with smoothCon
spline_model <- smoothCon(s(x,k=10,bs="cr"), data=data, knots=NULL)[[1]]
X <- spline_model$X
S <- spline_model$S[[1]] # penalty matrix S
#2. Define loss function with psi, lambda, sigma
pen_ssqr <- function(beta, X, y, S,
lambda,tau, psi =0.1, sigma =1){
mu <- X %*% beta
res <- (y-mu)
pen <- as.numeric(t(beta) %*% S %*% beta) #produces a 1x1 matrix
#loss <- sum((y - mu)^2) + lambda * pen # this is for least square
#smoothed pinball loss For Quantile Regression
pinball_loss <- sum((tau -plogis(res/psi))* res)
penalty <- lambda * pen
return(pinball_loss+penalty)
}
fit <- lm(y ~ X-1, data = data)
matplot(X, x=x, type ='l', ylab = "Spline Basis Function")
coef(fit)
plot (x,y, col="grey")
lines(x, X %*% coef(fit), type = 'l', col = "red", lwd = 2)
#3. Optimise
#assume sigma =1
#       psi is small number
#develop code to estimate beta
#FIXED PARAMETERS
tau <- 0.9 #quantile level -> 90th percentile
lambda <- 100
psi <- 0.1
sigma <- 1 #fixed
fit_pen <- optim(par = fit$coef,
fn = pen_ssqr,
y = y, X = X,
tau = tau, S = S,
lambda = lambda, method = "BFGS",
)
#visualisation
plot(x, y, col = "grey")
lines(x,X %*% coef(fit), type = 'l', col = "blue", lwd = 2) # this is median
lines(x, X %*% fit_pen$par, type = 'l', col = "red", lwd = 2)
#3. Optimise
#assume sigma =1
#       psi is small number
#develop code to estimate beta
#FIXED PARAMETERS
tau <- 0.5 #quantile level -> 90th percentile
lambda <- 100
psi <- 0.1
sigma <- 1 #fixed
fit_pen <- optim(par = fit$coef,
fn = pen_ssqr,
y = y, X = X,
tau = tau, S = S,
lambda = lambda, method = "BFGS",
)
#visualisation
plot(x, y, col = "grey")
lines(x,X %*% coef(fit), type = 'l', col = "blue", lwd = 2) # this is median
lines(x, X %*% fit_pen$par, type = 'l', col = "red", lwd = 2)
library(mgcv)
#1. Build spline model with smoothCon
spline_model <- smoothCon(s(x,k=10,bs="cr"), data=data, knots=NULL)[[1]]
X <- spline_model$X
S <- spline_model$S[[1]] # penalty matrix S
#2. Define loss function with psi, lambda, sigma
pen_ssqr <- function(beta, X, y, S,
lambda,tau, psi =0.1, sigma =1){
mu <- X %*% beta
res <- (y-mu)
pen <- as.numeric(t(beta) %*% S %*% beta) #produces a 1x1 matrix
#loss <- sum((y - mu)^2) + lambda * pen # this is for least square
#smoothed pinball loss For Quantile Regression
pinball_loss <- - sum((tau -plogis(res/psi))* res)
penalty <- lambda * pen
return(pinball_loss+penalty)
}
fit <- lm(y ~ X-1, data = data)
matplot(X, x=x, type ='l', ylab = "Spline Basis Function")
coef(fit)
plot (x,y, col="grey")
lines(x, X %*% coef(fit), type = 'l', col = "red", lwd = 2)
#3. Optimise
#assume sigma =1
#       psi is small number
#develop code to estimate beta
#FIXED PARAMETERS
tau <- 0.5 #quantile level -> 90th percentile
lambda <- 100
psi <- 0.1
sigma <- 1 #fixed
fit_pen <- optim(par = fit$coef,
fn = pen_ssqr,
y = y, X = X,
tau = tau, S = S,
lambda = lambda, method = "BFGS",
)
#visualisation
plot(x, y, col = "grey")
lines(x,X %*% coef(fit), type = 'l', col = "blue", lwd = 2) # this is median
lines(x, X %*% fit_pen$par, type = 'l', col = "red", lwd = 2)
#3. Optimise
#assume sigma =1
#       psi is small number
#develop code to estimate beta
#FIXED PARAMETERS
tau <- 0.9 #quantile level -> 90th percentile
lambda <- 100
psi <- 0.1
sigma <- 1 #fixed
fit_pen <- optim(par = fit$coef,
fn = pen_ssqr,
y = y, X = X,
tau = tau, S = S,
lambda = lambda, method = "BFGS",
)
#visualisation
plot(x, y, col = "grey")
lines(x,X %*% coef(fit), type = 'l', col = "blue", lwd = 2) # this is median
lines(x, X %*% fit_pen$par, type = 'l', col = "red", lwd = 2)
knitr::opts_chunk$set(echo = TRUE)
require("knitr")
n <- 1e3
x <- seq(0, 2*pi, length.out = n)
y <- sin(x) + rnorm(n, 0, 0.5)
dat <- data.frame(x = x, y = y)
plot(x, y)
library(mgcv)
sm <- smoothCon(s(x, k = 10, bs = "cr"), data=dat, knots=NULL)[[1]]
X <- sm$X
S <- sm$S[[1]] # penalty matrix S
fit <- lm(y ~ X-1, data = dat)
matplot(X, x = x, type = 'l', ylab = "Spline basis function")
# Computes ELF density and its derivatives w.r.t mu
dlf <- function(x, tau, mu, psi, log = FALSE, deriv = 0)
{
sig <- 1
y <- (x - mu) / sig
out <- (1-tau) * y - psi * log(1 + exp(y / psi)) - log(sig * psi * beta(psi * (1 - tau), tau * psi))
if (!log) out <- exp(out)
if(deriv > 0)
{
out <- list("d" = out)
dl <- dlogis(x, mu, psi*sig)
pl <- plogis(x, mu, psi*sig)
out$D <- sum((pl - (1-tau)) / sig)
if(deriv > 1)
{
out$D2 <- sum(-dl / sig)
}
}
return(out)
}
# Computes negative log-likelihood as a function of beta
negllkFun <- function(par, tau, psi, dat, X)
{
mu <- X %*% par
out <- - sum( dlf(x = dat, tau = tau, mu = mu, psi = psi, log = TRUE))
return(out)
}
# Computes derivative of the log-likelihood w.r.t. beta
negGrad <- function(par, tau, psi, dat, X)
{
mu <- X %*% par
tmp <- lapply(1:length(mu),
function(ii){
a <- - dlf(x = dat[ii], tau = tau, mu = mu[ii],
psi = psi, log = TRUE, deriv = 1)$D
return(a[1] * X[ii, ])
}
)
out <- Reduce("+", tmp)
return(out)
}
# version one of penalty
pen_negllk <- function(par, tau, psi, dat, X, S, lambda) {
negllkFun(par, tau, psi, dat, X) + as.numeric(lambda * t(par) %*% (S %*% par))
}
pen_negGrad <- function(par, tau, psi, dat, X, S, lambda) {
as.numeric(negGrad(par, tau, psi, dat, X)) + 2 * lambda * as.vector(S %*% par)
}
# second version of penalty
pen_ssqr <- function(beta, X, y, S,
lambda,tau, psi =0.1, sigma =1){
mu <- X %*% beta
res <- (y-mu)
pen <- as.numeric(t(beta) %*% S %*% beta) #produces a 1x1 matrix
loss <- - sum((tau - plogis(res/psi))* res)
penalty <- lambda * pen
return(loss+penalty)
}
tau <- 0.5
psi <- 0.1
lambda <- 1000
sigma <- 1
fit_pen <- optim(par = coef(fit),
fn = pen_ssqr,
y = y, X = X,
tau = tau, S = S,
lambda = lambda, method = "BFGS",
)
#fit_pen <- optim(par = coef(fit),
#fn = pen_negllk,
#gr = pen_negGrad,
#tau = tau, psi = psi, dat = dat$y, X = X, S = S, lambda = lambda,
#method = "BFGS")
plot(x, y, col = "grey", main = paste("Quantile Regression tau =", tau))
lines(x, X %*% fit_pen$par, col = "red", lwd = 2)
lines(x, sin(x), col = "blue", lty = 2, lwd = 2) # True function
legend("topright", legend = c("Data", "Fitted", "True"),
col = c("grey", "red", "blue"), lty = c(NA, 1, 2), pch = c(1, NA, NA))
tau <- 0.5
psi <- 0.1
lambda <- 100
sigma <- 1
fit_pen <- optim(par = coef(fit),
fn = pen_ssqr,
y = y, X = X,
tau = tau, S = S,
lambda = lambda, method = "BFGS",
)
#fit_pen <- optim(par = coef(fit),
#fn = pen_negllk,
#gr = pen_negGrad,
#tau = tau, psi = psi, dat = dat$y, X = X, S = S, lambda = lambda,
#method = "BFGS")
plot(x, y, col = "grey", main = paste("Quantile Regression tau =", tau))
lines(x, X %*% fit_pen$par, col = "red", lwd = 2)
lines(x, sin(x), col = "blue", lty = 2, lwd = 2) # True function
legend("topright", legend = c("Data", "Fitted", "True"),
col = c("grey", "red", "blue"), lty = c(NA, 1, 2), pch = c(1, NA, NA))
tau <- 0.0
psi <- 0.1
lambda <- 100
sigma <- 1
fit_pen <- optim(par = coef(fit),
fn = pen_ssqr,
y = y, X = X,
tau = tau, S = S,
lambda = lambda, method = "BFGS",
)
#fit_pen <- optim(par = coef(fit),
#fn = pen_negllk,
#gr = pen_negGrad,
#tau = tau, psi = psi, dat = dat$y, X = X, S = S, lambda = lambda,
#method = "BFGS")
plot(x, y, col = "grey", main = paste("Quantile Regression tau =", tau))
lines(x, X %*% fit_pen$par, col = "red", lwd = 2)
lines(x, sin(x), col = "blue", lty = 2, lwd = 2) # True function
legend("topright", legend = c("Data", "Fitted", "True"),
col = c("grey", "red", "blue"), lty = c(NA, 1, 2), pch = c(1, NA, NA))
tau <- 0.9
psi <- 0.1
lambda <- 100
sigma <- 1
fit_pen <- optim(par = coef(fit),
fn = pen_ssqr,
y = y, X = X,
tau = tau, S = S,
lambda = lambda, method = "BFGS",
)
#fit_pen <- optim(par = coef(fit),
#fn = pen_negllk,
#gr = pen_negGrad,
#tau = tau, psi = psi, dat = dat$y, X = X, S = S, lambda = lambda,
#method = "BFGS")
plot(x, y, col = "grey", main = paste("Quantile Regression tau =", tau))
lines(x, X %*% fit_pen$par, col = "red", lwd = 2)
lines(x, sin(x), col = "blue", lty = 2, lwd = 2) # True function
legend("topright", legend = c("Data", "Fitted", "True"),
col = c("grey", "red", "blue"), lty = c(NA, 1, 2), pch = c(1, NA, NA))
tau <- 0.9
psi <- 0.1
lambda <- 100
sigma <- 1
# fit_pen <- optim(par = coef(fit),
#                  fn = pen_ssqr,
#                  y = y, X = X,
#                  tau = tau, S = S,
#                  lambda = lambda, method = "BFGS",
#                  )
fit_pen <- optim(par = coef(fit),
fn = pen_negllk,
gr = pen_negGrad,
tau = tau, psi = psi, dat = dat$y, X = X, S = S, lambda = lambda,
method = "BFGS")
plot(x, y, col = "grey", main = paste("Quantile Regression tau =", tau))
lines(x, X %*% fit_pen$par, col = "red", lwd = 2) #the quantile
lines(x, sin(x), col = "blue", lty = 2, lwd = 2) # True function
legend("topright", legend = c("Data", "Fitted", "True"),
col = c("grey", "red", "blue"), lty = c(NA, 1, 2), pch = c(1, NA, NA))
library(mgcv)
#1. Build spline model with smoothCon
spline_model <- smoothCon(s(x,k=10,bs="cr"), data=data, knots=NULL)[[1]]
X <- spline_model$X
S <- spline_model$S[[1]] # penalty matrix S
#2. Define loss function with psi, lambda, sigma
pen_ssqr <- function(beta, X, y, S,
lambda,tau, psi =0.1, sigma =1){
mu <- X %*% beta
res <- (y-mu)
pen <- as.numeric(t(beta) %*% S %*% beta) #produces a 1x1 matrix
#loss <- sum((y - mu)^2) + lambda * pen # this is for least square
#smoothed pinball loss For Quantile Regression
pinball_loss <- sum((tau -(res<0))* res)
penalty <- lambda * pen
return(pinball_loss+penalty)
}
fit <- lm(y ~ X-1, data = data)
matplot(X, x=x, type ='l', ylab = "Spline Basis Function")
coef(fit)
plot (x,y, col="grey")
lines(x, X %*% coef(fit), type = 'l', col = "red", lwd = 2)
n <- 1e3
x <- seq(0, 2*pi, length.out =n)
y <- cos(x) +rnorm(n,0,0.5)
data <- data.frame (x=x, y=y)
plot(x,y)
library(mgcv)
#1. Build spline model with smoothCon
spline_model <- smoothCon(s(x,k=10,bs="cr"), data=data, knots=NULL)[[1]]
X <- spline_model$X
S <- spline_model$S[[1]] # penalty matrix S
#2. Define loss function with psi, lambda, sigma
pen_ssqr <- function(beta, X, y, S,
lambda,tau, psi =0.1, sigma =1){
mu <- X %*% beta
res <- (y-mu)
pen <- as.numeric(t(beta) %*% S %*% beta) #produces a 1x1 matrix
#loss <- sum((y - mu)^2) + lambda * pen # this is for least square
#smoothed pinball loss For Quantile Regression
pinball_loss <- sum((tau -(res<0))* res)
penalty <- lambda * pen
return(pinball_loss+penalty)
}
fit <- lm(y ~ X-1, data = data)
matplot(X, x=x, type ='l', ylab = "Spline Basis Function")
coef(fit)
plot (x,y, col="grey")
lines(x, X %*% coef(fit), type = 'l', col = "red", lwd = 2)
#3. Optimise
#assume sigma =1
#       psi is small number
#develop code to estimate beta
#FIXED PARAMETERS
tau <- 0.9 #quantile level -> 90th percentile
lambda <- 100
psi <- 0.1
sigma <- 1 #fixed
fit_pen <- optim(par = fit$coef,
fn = pen_ssqr,
y = y, X = X,
tau = tau, S = S,
lambda = lambda, method = "BFGS",
)
#visualisation
plot(x, y, col = "grey")
lines(x,X %*% coef(fit), type = 'l', col = "blue", lwd = 2) # this is median
lines(x, X %*% fit_pen$par, type = 'l', col = "red", lwd = 2)
# version one of penalty
pen_negllk <- function(par, tau, psi, dat, X, S, lambda) {
negllkFun(par, tau, psi, dat, X) + as.numeric(lambda * t(par) %*% (S %*% par))
}
pen_negGrad <- function(par, tau, psi, dat, X, S, lambda) {
as.numeric(negGrad(par, tau, psi, dat, X)) + 2 * lambda * as.vector(S %*% par)
}
# second version of penalty
pen_ssqr <- function(beta, X, y, S,
lambda,tau, psi =0.1, sigma =1){
mu <- X %*% beta
res <- (y-mu)
pen <- as.numeric(t(beta) %*% S %*% beta) #produces a 1x1 matrix
loss <- sum((tau - (res<0))* res)
penalty <- lambda * pen
return(loss+penalty)
}
tau <- 0.9
psi <- 0.1
lambda <- 100
sigma <- 1
fit_pen <- optim(par = coef(fit),
fn = pen_ssqr,
y = y, X = X,
tau = tau, S = S,
lambda = lambda, method = "BFGS",
)
# fit_pen <- optim(par = coef(fit),
#                 fn = pen_negllk,
#                 gr = pen_negGrad,
#                 tau = tau, psi = psi, dat = dat$y, X = X, S = S, lambda = lambda,
#                 method = "BFGS")
plot(x, y, col = "grey", main = paste("Quantile Regression tau =", tau))
lines(x, X %*% fit_pen$par, col = "red", lwd = 2) #the quantile
lines(x, sin(x), col = "blue", lty = 2, lwd = 2) # True function
legend("topright", legend = c("Data", "Fitted", "True"),
col = c("grey", "red", "blue"), lty = c(NA, 1, 2), pch = c(1, NA, NA))
n <- 1e3
x <- seq(0, 2*pi, length.out = n)
y <- sin(x) + rnorm(n, 0, 0.5)
dat <- data.frame(x = x, y = y)
plot(x, y)
tau <- 0.9
psi <- 0.1
lambda <- 100
sigma <- 1
fit_pen <- optim(par = coef(fit),
fn = pen_ssqr,
y = y, X = X,
tau = tau, S = S,
lambda = lambda, method = "BFGS",
)
# fit_pen <- optim(par = coef(fit),
#                 fn = pen_negllk,
#                 gr = pen_negGrad,
#                 tau = tau, psi = psi, dat = dat$y, X = X, S = S, lambda = lambda,
#                 method = "BFGS")
plot(x, y, col = "grey", main = paste("Quantile Regression tau =", tau))
lines(x, X %*% fit_pen$par, col = "red", lwd = 2) #the quantile
lines(x, sin(x), col = "blue", lty = 2, lwd = 2) # True function
legend("topright", legend = c("Data", "Fitted", "True"),
col = c("grey", "red", "blue"), lty = c(NA, 1, 2), pch = c(1, NA, NA))
